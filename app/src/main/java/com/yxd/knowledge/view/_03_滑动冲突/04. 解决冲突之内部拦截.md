# 解决冲突之内部拦截

1. 父容器把所有事件传递给子View处理。
2. 如果子View需要事件，则进行消耗，否则交由父容器进行处理。

### requestDisallowInterceptTouchEvent

> public void requestDisallowInterceptTouchEvent(boolean disallowIntercept);

### 父容器代码

``` java
@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    int action = ev.getAction();
    if(action == MotionEvent.ACTION_DOWN){
        // 父容器的 ACTION_DOWN 事件不能拦截。
        return false;
    } else {
        return true;
    }
}
```

### 子View伪代码

``` java
public boolean dispatchTouchEvent(MotionEvent ev) {
    switch (ev.getAction()){
        case MotionEvent.ACTION_DOWN:
            // 关键点①
            // requestDisallowInterceptTouchEvent：请求拒绝拦截触摸事件
            // 使父容器无法拦截除了ACTION_DOWN之外的任何事件
            getParent().requestDisallowInterceptTouchEvent(true);
            break;
        case MotionEvent.ACTION_MOVE:
            if(父控件需要此点击事件){
                // 关键点②
                // 请求父容器拦截触摸事件，相应事件交给了父容器进行处理
                getParent().requestDisallowInterceptTouchEvent(false);
            }
            break;
    }
}
```
