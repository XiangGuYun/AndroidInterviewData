# 解决冲突之内部拦截

由子View决定父容器是否要拦截。

1. 父容器把所有事件传递给子View处理。
2. 如果子View需要事件，则进行消耗，否则交由父容器进行处理。

### requestDisallowInterceptTouchEvent方法

```java
// 请求不允许拦截触摸事件

// 当子View不希望父容器和祖先容器通过ViewGroup.onInterceptTouchEvent(MotionEvent)拦截触摸事件时调用。

// 这个父容器应该把这个调用传递给它的父容器。这个父容在触碰期间必须服从这个请求(也就是说，只有在这个父进程收到一个up或cancel后才清除标志。)

// disallowIntercept：是否不允许拦截
public void requestDisallowInterceptTouchEvent(boolean disallowIntercept);
```

### 父容器代码

``` java
@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    int action = ev.getAction();
    if(action == MotionEvent.ACTION_DOWN){
        // 父容器的 ACTION_DOWN 事件不能拦截。
        return false;
    } else {
        return true;
    }
}
```

### 子View伪代码

``` java
public boolean dispatchTouchEvent(MotionEvent ev) {
    switch (ev.getAction()){
        case MotionEvent.ACTION_DOWN:
            // 关键点①
            // requestDisallowInterceptTouchEvent：请求拒绝拦截触摸事件
            // 使父容器无法拦截除了ACTION_DOWN之外的任何事件
            getParent().requestDisallowInterceptTouchEvent(true);
            break;
        case MotionEvent.ACTION_MOVE:
            if(父控件需要此点击事件){
                // 关键点②
                // 请求父容器拦截触摸事件，相应事件交给了父容器进行处理
                getParent().requestDisallowInterceptTouchEvent(false);
            }
            break;
    }
}
```
