# 初始容量和扩容机制

## 初始容量
jdk1.8之前是16，之后是0（容量在首次put后设置）。

> 

***

## 扩容
扩容是耗性能的操作，最好一开始就设定好初始容量，避免频繁扩容。
> 扩容后，需要重新计算hash值和下标。

### 扩容时机
数据大小 > 容量 x 负载因子0.75

> 例如，初始容量为16的HashMap在插入第13个元素时，就会进行扩容。

### 扩容过程

1. 创建一个原数组<font color=#dea32c>**2倍**</font>大小的新数组。
2. 遍历原数组，将所有的entry移入新数组。
3. 重新计算元素的hash值。
> 🤔：为什么要重新计算？  
> ***
> 数组下标 = hashcode%(length-1)，当长度发生改变时，原先的下标值也会发生改变。

***

## 为什么容量必须是2的N次幂？ 

首先必须掌握Java的[位运算](doc/java位运算.md)。

### 本质原因：避免hash冲突，提升取模效率。  

#### 01. HashMap内部取模操作
``` java
// 这也是一个取模操作，使用位运算效率要高于%
// 💡：capacity必须的2的n次幂才能用&取模
(capacity - 1) & hash
```

[&运算符与%运算符取模效率比较](code/QuMoXiaoLv.java)

#### 02. (2^N-1) & HashCode
所有2次幂的数-1转换为2进制后，低位都是连续的1。
> 7 : 0000 0111
> 
> 31: 0001 1111
> 
> 63: 0011 1111
> 
> 127:0111 1111
> 
> ……

> 位与（&）：二元运算符，两个为1时结果为1，否则为0

如果低位存在0，那么无论&什么，结果都是0，这样的话会增加hash冲突的概率。



