# into
***

## into

``` java
 @NonNull
  public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
    
    // çœç•¥...

    return into(
        glideContext.buildImageViewTarget(view, transcodeClass),
        /*targetListener=*/ null,
        requestOptions,
        Executors.mainThreadExecutor());
  }
```
***
### ç‚¹è¿›å»into

``` java
private <Y extends Target<TranscodeType>> Y into(
      @NonNull Y target,
      @Nullable RequestListener<TranscodeType> targetListener,
      BaseRequestOptions<?> options,
      Executor callbackExecutor) {
    Preconditions.checkNotNull(target);
    if (!isModelSet) {
      throw new IllegalArgumentException("You must call #load() before calling #into()");
    }
    
    // Requestæ˜¯ä¸€ä¸ªæ¥å£ï¼Œå®é™…è¿”å›çš„æ˜¯ä¸€ä¸ªSingleRequestå¯¹è±¡ã€‚
    Request request = buildRequest(target, targetListener, options, callbackExecutor);
    
    //------------------------------------------------
    // å¦‚æœä¹‹å‰è¿˜æœ‰è¯·æ±‚æœªå®Œæˆï¼Œåˆ™æ‰§è¡Œä¹‹å‰çš„è¯·æ±‚
    Request previous = target.getRequest();
    if (request.isEquivalentTo(previous)
        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
      if (!Preconditions.checkNotNull(previous).isRunning()) {
        previous.begin();
      }
      return target;
    }
    //------------------------------------------------

    requestManager.clear(target);
    target.setRequest(request);
    // æ‰§è¡Œè¯·æ±‚
    requestManager.track(target, request);

    return target;
  }
```
***
### ç‚¹è¿›å»requestManager.track

``` java
  synchronized void track(@NonNull Target<?> target, @NonNull Request request) {
    targetTracker.track(target);
    requestTracker.runRequest(request);
  }
```
***
### ç‚¹è¿›å»requestTracker.runRequest

``` java
  public void runRequest(@NonNull Request request) {
    // å°†è¯·æ±‚æ·»åŠ åˆ°requestsä¸­
    requests.add(request);
    if (!isPaused) {
      // å¦‚æœä¸å¤„äºæš‚åœçŠ¶æ€ï¼Œåˆ™å¼€å§‹å¼‚æ­¥è¯·æ±‚
      // å®é™…è°ƒç”¨çš„æ˜¯SingleRequestçš„beginæ–¹æ³•
      request.begin();
    } else {
      // é‡Šæ”¾è¯·æ±‚èµ„æº
      request.clear();
      if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "Paused, delaying request");
      }
      // å°†è¯·æ±‚æ·»åŠ åˆ°pendingRequestsä¸­ç­‰å¾…å¤„ç†
      pendingRequests.add(request);
    }
  }
```
>``` java
> // æ­£åœ¨æ‰§è¡Œçš„è¯·æ±‚
> private final Set<Request> requests =
>         Collections.newSetFromMap(new WeakHashMap<Request, Boolean>());
>```

>``` java
> // ä¸€ç»„å°šæœªå®Œæˆçš„è¯·æ±‚ï¼Œå®ƒä»¬è¢«æ’é˜Ÿç­‰å¾…å†æ¬¡è¿è¡Œã€‚
> private final Set<Request> pendingRequests = new HashSet<>();
>```
***
## ç‚¹è¿›å»SingleRequest.begin
``` java
  @Override
  public void begin() {
    synchronized (requestLock) {
      
      // çœç•¥...

      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
        // ä¼ å…¥äº†å›¾ç‰‡çš„å®½é«˜
        onSizeReady(overrideWidth, overrideHeight);
      } else {
        target.getSize(this);
      }

      // çœç•¥...
      
    }
  }
```
***
## ç‚¹è¿›onSizeReady
``` java
  @Override
  public void onSizeReady(int width, int height) {
    stateVerifier.throwIfRecycled();
    synchronized (requestLock) {
    
      // çœç•¥...
      
      loadStatus =
          engine.load(
              glideContext,
              model,
              requestOptions.getSignature(),
              this.width,
              this.height,
              requestOptions.getResourceClass(),
              transcodeClass,
              priority,
              requestOptions.getDiskCacheStrategy(),
              requestOptions.getTransformations(),
              requestOptions.isTransformationRequired(),
              requestOptions.isScaleOnlyOrNoTransform(),
              requestOptions.getOptions(),
              requestOptions.isMemoryCacheable(),
              requestOptions.getUseUnlimitedSourceGeneratorsPool(),
              requestOptions.getUseAnimationPool(),
              requestOptions.getOnlyRetrieveFromCache(),
              this,
              callbackExecutor);

        // çœç•¥...
        
    }
  }
```
***
## ç‚¹è¿›engine.load
``` java
 /**
 * å¯åŠ¨ç»™å®šå‚æ•°çš„åŠ è½½ã€‚ 
 
 * å¿…é¡»åœ¨ä¸»çº¿ç¨‹ä¸Šè¢«è°ƒç”¨ã€‚
  
 * ä»»ä½•è¯·æ±‚çš„æµç¨‹å¦‚ä¸‹: 
 
 * æ£€æŸ¥å½“å‰ä½¿ç”¨çš„æ´»åŠ¨èµ„æºé›†ï¼Œå¦‚æœå­˜åœ¨ï¼Œè¿”å›æ´»åŠ¨èµ„æºï¼Œ
 * å¹¶å°†ä»»ä½•æ–°çš„ä¸æ´»åŠ¨èµ„æºç§»åŠ¨åˆ°å†…å­˜ç¼“å­˜ä¸­ã€‚ 
 
 * æ£€æŸ¥å†…å­˜ç¼“å­˜ï¼Œå¦‚æœå­˜åœ¨ï¼Œæä¾›ç¼“å­˜çš„èµ„æºã€‚ 
 
 * æ£€æŸ¥å½“å‰æ­£åœ¨è¿è¡Œçš„è´Ÿè½½ï¼Œå¦‚æœæœ‰ï¼Œå°†cbæ·»åŠ åˆ°æ­£åœ¨è¿è¡Œçš„è´Ÿè½½ä¸­ã€‚ 
 
 * å¼€å§‹ä¸€ä¸ªæ–°çš„åŠ è½½ã€‚
 */
  public <R> LoadStatus load(...) {    
    // ä¸€ç§ä»…åœ¨å†…å­˜ä¸­ç”¨äºå¤šè·¯ä¼ è¾“çš„ç¼“å­˜é”®ã€‚
    // æ¯ä¸ªEngineKeyå¯¹åº”ä¸€ä¸ªè¿è¡Œæ—¶å›¾ç‰‡ç¼“å­˜
    EngineKey key = keyFactory.buildKey(...);

    EngineResource<?> memoryResource;
    synchronized (this) {
      // å°†å†…å­˜ä¸­è·å–ç¼“å­˜èµ„æº
      memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);

      if (memoryResource == null) {
        // å¦‚æœè¿è¡Œæ—¶ç¼“å­˜ä¸ºç©ºï¼Œæ‰§è¡ŒwaitForExistingOrStartNewJob
        return waitForExistingOrStartNewJob(...);
      }
    }
```
### ç‚¹è¿›loadFromMemory
``` java
  private EngineResource<?> loadFromMemory(
      EngineKey key, boolean isMemoryCacheable, long startTime) {
    if (!isMemoryCacheable) {
      return null;
    }
    // activeå’Œcacheçš„éƒ½æ˜¯è¿è¡Œæ—¶ç¼“å­˜ï¼Œå³åº”ç”¨é€€å‡ºè¿è¡Œåä¼šæ¶ˆå¤±çš„ç¼“å­˜
    // å…ˆä»è·å–æ´»åŠ¨ç¼“å­˜ä¸­å»æ‹¿èµ„æºï¼ˆä¸€çº§ç¼“å­˜ï¼‰
    EngineResource<?> active = loadFromActiveResources(key);
    if (active != null) {
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
      }
      // è¿”å›æ´»åŠ¨ç¼“å­˜
      return active;
    }
    
    // å†ä»å†…å­˜ç¼“å­˜ä¸­å»æ‹¿èµ„æºï¼ˆäºŒçº§ç¼“å­˜ï¼‰
    EngineResource<?> cached = loadFromCache(key);
    if (cached != null) {
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from cache", startTime, key);
      }
      // è¿”å›å†…å­˜ç¼“å­˜
      return cached;
    }

    return null;
  }
```
> ğŸ¤” ä¸ºä»€ä¹ˆè¿è¡Œæ—¶ç¼“å­˜è¦æä¸¤çº§ï¼Ÿ
> > æ­£åœ¨å±•ç¤ºçš„å›¾ç‰‡ä¼šæ”¾å…¥æ´»åŠ¨ç¼“å­˜
### ç‚¹è¿›waitForExistingOrStartNewJob
``` java
private <R> LoadStatus waitForExistingOrStartNewJob(...) {
    
    // æ£€æŸ¥å½“å‰æ˜¯å¦æœ‰å¯ç”¨çš„ç£ç›˜ç¼“å­˜
    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
    if (current != null) {
      current.addCallback(cb, callbackExecutor);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Added to existing load", startTime, key);
      }
      return new LoadStatus(cb, current);
    }
    
    // åˆ›å»ºå¼•æ“å·¥ä½œ
    // å°è£…äº†çº¿ç¨‹æ± 
    EngineJob<R> engineJob =
        engineJobFactory.build(
            key,
            isMemoryCacheable,
            useUnlimitedSourceExecutorPool,
            useAnimationPool,
            onlyRetrieveFromCache);
    
    // åˆ›å»ºè§£ç å·¥ä½œ
    // è´Ÿè´£ä»ç¼“å­˜æ•°æ®æˆ–åŸå§‹æºè§£ç èµ„æºï¼Œå¹¶åº”ç”¨è½¬æ¢å’Œè½¬ç ã€‚
    DecodeJob<R> decodeJob =
        decodeJobFactory.build(
            glideContext,
            model,
            key,
            signature,
            width,
            height,
            resourceClass,
            transcodeClass,
            priority,
            diskCacheStrategy,
            transformations,
            isTransformationRequired,
            isScaleOnlyOrNoTransform,
            onlyRetrieveFromCache,
            options,
            engineJob);

    jobs.put(key, engineJob);

    engineJob.addCallback(cb, callbackExecutor);
    // å¼€å¯å¼•æ“å·¥ä½œï¼Œå¹¶ä¼ å…¥è§£ç å·¥ä½œ
    engineJob.start(decodeJob);

    if (VERBOSE_IS_LOGGABLE) {
      logWithTimeAndKey("Started new load", startTime, key);
    }
    return new LoadStatus(cb, engineJob);
  }
```
### ç‚¹è¿›engineJob.start
``` java
  public synchronized void start(DecodeJob<R> decodeJob) {
    this.decodeJob = decodeJob;
    GlideExecutor executor =
        decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();
    // é€šè¿‡çº¿ç¨‹æ± æ¥æ‰§è¡ŒdecodeJob
    // é‚£ä¹ˆdecodeJobæ˜¯ä¸ªRunnableï¼Œä¸€å®šæœ‰runæ–¹æ³•
    executor.execute(decodeJob);
  }
```
### æ‰¾åˆ°decodeJob.run
``` java
  @Override
  public void run() {
   
    GlideTrace.beginSectionFormat("DecodeJob#run(reason=%s, model=%s)", runReason, model);
    
    DataFetcher<?> localFetcher = currentFetcher;
    try {
      if (isCancelled) {
        notifyFailed();
        return;
      }
      // å…³é”®æ–¹æ³•
      runWrapped();
    } catch (CallbackException e) {
      throw e;
    } catch (Throwable t) {
      if (stage != Stage.ENCODE) {
        throwables.add(t);
        notifyFailed();
      }
      if (!isCancelled) {
        throw t;
      }
      throw t;
    } finally {
      if (localFetcher != null) {
        localFetcher.cleanup();
      }
      GlideTrace.endSection();
    }
  }
```
### ç‚¹è¿›runWrapped
``` java
  private void runWrapped() {
    switch (runReason) {
      case INITIALIZE:
        stage = getNextStage(Stage.INITIALIZE);
        currentGenerator = getNextGenerator();
        runGenerators();
        break;
      case SWITCH_TO_SOURCE_SERVICE:
        runGenerators();
        break;
      case DECODE_DATA:
        decodeFromRetrievedData();
        break;
      default:
        throw new IllegalStateException("Unrecognized run reason: " + runReason);
    }
  }
```
### ç‚¹è¿›getNextGenerator
``` java
  private DataFetcherGenerator getNextGenerator() {
    switch (stage) {
      case RESOURCE_CACHE:
        return new ResourceCacheGenerator(decodeHelper, this);
      case DATA_CACHE:
        return new DataCacheGenerator(decodeHelper, this);
      case SOURCE:
        // å¦‚æœæ²¡æœ‰é…ç½®ç¼“å­˜ç­–ç•¥åˆ™èµ°è¿™æ¡åˆ†æ”¯
        return new SourceGenerator(decodeHelper, this);
      case FINISHED:
        return null;
      default:
        throw new IllegalStateException("Unrecognized stage: " + stage);
    }
  }
```
### ç‚¹è¿›runGenerators
``` java
  private void runGenerators() {
    currentThread = Thread.currentThread();
    startFetchTime = LogTime.getLogTime();
    boolean isStarted = false;
    while (!isCancelled
        && currentGenerator != null
        // å¦‚æœæ²¡æœ‰é…ç½®ç¼“å­˜ç­–ç•¥ï¼Œåˆ™æ‰§è¡Œçš„æ˜¯SourceGeneratorçš„startNext
        && !(isStarted = currentGenerator.startNext())) {
      stage = getNextStage(stage);
      currentGenerator = getNextGenerator();

      if (stage == Stage.SOURCE) {
        reschedule();
        return;
      }
    }
    // We've run out of stages and generators, give up.
    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {
      notifyFailed();
    }

    // Otherwise a generator started a new load and we expect to be called back in
    // onDataFetcherReady.
  }
```
### SourceGenerator.startNext
``` java
  @Override
  public boolean startNext() {
    
    // ...

    loadData = null;
    boolean started = false;
    while (!started && hasNextModelLoader()) {
      loadData = helper.getLoadData().get(loadDataListIndex++);
      if (loadData != null
          && (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())
              || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {
        started = true;
        startNextLoad(loadData);
      }
    }
    return started;
  }
```
### ç‚¹è¿›helper.getLoadData
``` java
  List<LoadData<?>> getLoadData() {
    if (!isLoadDataSet) {
      isLoadDataSet = true;
      loadData.clear();
      List<ModelLoader<Object, ?>> modelLoaders = glideContext.getRegistry().getModelLoaders(model);
      //noinspection ForLoopReplaceableByForEach to improve perf
      for (int i = 0, size = modelLoaders.size(); i < size; i++) {
        ModelLoader<Object, ?> modelLoader = modelLoaders.get(i);
        // æ­¤å¤„å®é™…è°ƒç”¨çš„æ˜¯HttpGlideUrlLoaderçš„buildLoadData
        LoadData<?> current = modelLoader.buildLoadData(model, width, height, options);
        if (current != null) {
          loadData.add(current);
        }
      }
    }
    return loadData;
  }
```
***
## ç‚¹è¿›HttpGlideUrlLoaderçš„buildLoadData
``` java
 @Override
  public LoadData<InputStream> buildLoadData(
      @NonNull GlideUrl model, int width, int height, @NonNull Options options) {
    // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time
    // spent parsing urls.
    GlideUrl url = model;
    if (modelCache != null) {
      url = modelCache.get(model, 0, 0);
      if (url == null) {
        modelCache.put(model, 0, 0, model);
        url = model;
      }
    }
    int timeout = options.get(TIMEOUT);
    // HttpUrlFetcheræ˜¯è¯·æ±‚ç½‘ç»œå›¾ç‰‡çš„ç±»
    return new LoadData<>(url, new HttpUrlFetcher(url, timeout));
  }

```
### ç‚¹è¿›HttpUrlFetcher.loadData
loadData -> loadDataWithRedirects -> buildAndConfigureConnection
``` java
  // æ„å»ºå¹¶é…ç½®HttpUrlConnection
  private HttpURLConnection buildAndConfigureConnection(URL url, Map<String, String> headers)
      throws HttpException {
    HttpURLConnection urlConnection;
    try {
      urlConnection = connectionFactory.build(url);
    } catch (IOException e) {
      throw new HttpException("URL.openConnection threw", /*statusCode=*/ 0, e);
    }
    for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(timeout);
    urlConnection.setReadTimeout(timeout);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);
    // Stop the urlConnection instance of HttpUrlConnection from following redirects so that
    // redirects will be handled by recursive calls to this method, loadDataWithRedirects.
    urlConnection.setInstanceFollowRedirects(false);
    return urlConnection;
  }
```
``` java
    // HttpUrlFetcher -> loadDataWithRedirects
    try {
      // å¦‚æœè¿æ¥å¤±è´¥ï¼Œæ˜¾å¼è¿æ¥ä»¥é¿å…è§£ç å™¨ä¸­çš„é”™è¯¯.
      urlConnection.connect();
      // è®¾ç½®æµï¼Œä½¿å…¶åœ¨æ¸…ç†æ—¶å…³é—­ï¼Œä»¥é¿å…èµ„æºæ³„æ¼. See #2352.
      stream = urlConnection.getInputStream();
    } catch (IOException e) {
      throw new HttpException(
          "Failed to connect or obtain data", getHttpStatusCodeOrInvalid(urlConnection), e);
    }

    if (isCancelled) {
      return null;
    }

    final int statusCode = getHttpStatusCodeOrInvalid(urlConnection);
    if (isHttpOk(statusCode)) {
      return getStreamForSuccessfulRequest(urlConnection);
    } else if (isHttpRedirect(statusCode)) {
      String redirectUrlString = urlConnection.getHeaderField(REDIRECT_HEADER_FIELD);
      if (TextUtils.isEmpty(redirectUrlString)) {
        throw new HttpException("Received empty or null redirect url", statusCode);
      }
      URL redirectUrl;
      try {
        redirectUrl = new URL(url, redirectUrlString);
      } catch (MalformedURLException e) {
        throw new HttpException("Bad redirect url: " + redirectUrlString, statusCode, e);
      }
      // Closing the stream specifically is required to avoid leaking ResponseBodys in addition
      // to disconnecting the url connection below. See #2352.
      cleanup();
      return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    } else if (statusCode == INVALID_STATUS_CODE) {
      throw new HttpException(statusCode);
    } else {
      try {
        throw new HttpException(urlConnection.getResponseMessage(), statusCode);
      } catch (IOException e) {
        throw new HttpException("Failed to get a response message", statusCode, e);
      }
    }
```

